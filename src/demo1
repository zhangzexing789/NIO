http://www.iteye.com/magazines/132-Java-NIO
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.RandomAccessFile;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.IntBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Demo1 {
    /**
     * 1、面向缓冲（面向流）：读写数据均需要先进入缓冲区，待缓冲区处于待处理状态，才进行数据读写操作；数据在缓冲区可进行前后移动
     *                 （面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。）
     * 2、阻塞与非阻塞IO ：当线程在进行读取或者写入数据时，直至读取数据或者完全写入数据前，线程只能等待而不能其他操作，就是阻塞式；相反地，线程可进行
     *                  其他操作，就是非阻塞式。
     * 3、面向通道：  通道是双向的既可以写、也可以读；传统IO只能是单向的
     *
     */

    public void readFile(String path,String model) throws Exception {
        RandomAccessFile randomAccessFile = new RandomAccessFile(path,model);
            FileChannel fileChannel = randomAccessFile.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        int byteRead = fileChannel.read(byteBuffer);
        while (byteRead != -1){
            byteBuffer.flip();
            System.out.println("byteRead:"+byteRead);
            while (byteBuffer.hasRemaining()){
                System.out.print((char) byteBuffer.get());
            }
        byteBuffer.clear();
        byteRead = fileChannel.read(byteBuffer);
        }
        randomAccessFile.close();
    }

    /**
     * 以下是Java NIO里关键的Buffer实现：
     *
     * ByteBuffer
     * CharBuffer
     * DoubleBuffer
     * FloatBuffer
     * IntBuffer
     * LongBuffer
     * ShortBuffer
     *
     * 关键属性
     * capacity    缓冲区大小
     * position    写数据时表示当前位置，并且会自动移至下一个可写位置（position < capacity）;读数据时，最开始会重置为0,并自动移至下一个可读位置（position < limit）
     * limit       写数据时 limit = capacity ,读数据时 limit  为写完数据的　position
     */
    public void bufferTest(){
        //设置缓冲区大小,pos = 0,limt = 1024,allocate = 1024
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        //向缓冲区添加数据,pos 表示写入数据后在缓冲区的末位置
        byteBuffer.put("ByteBuffer test".getBytes());//pos = 15
        //将缓冲区切换成读模式,limt 表示缓冲区中数据量的大小,即是写入数据后的末坐标 pos
        byteBuffer.flip();//pos = 15,limt = 15
        //读数据，当pos<limt,return true
        while (byteBuffer.hasRemaining()) {
            //缓冲区拿数据
            System.out.print((char) byteBuffer.get());
        }
        //ByteBuffer test
        System.out.println();

        CharBuffer charBuffer = CharBuffer.allocate(100);
        charBuffer.put("CharBuffer test");
        charBuffer.append('d');//return put('d');
        charBuffer.flip();
        while (charBuffer.hasRemaining()){
            System.out.print(charBuffer.get());
        }
        //CharBuffer testd
    }
    /**
     * allocate() - 分配一块缓冲区　　
     * put() -  向缓冲区写数据
     * get() - 向缓冲区读数据　　
     * filp() - 将缓冲区从写模式切换到读模式　　
     * clear() - 从读模式切换到写模式，不会清空数据，但后续写数据会覆盖原来的数据，即使有部分数据没有读，也会被遗忘；　　
     * compact() - 从读数据切换到写模式，数据不会被清空，会将所有未读的数据copy到缓冲区头部，后续写数据不会覆盖，而是在这些数据之后写数据
     * mark() - 对position做出标记，配合reset使用
     * reset() - 将position置为标记值　
     * @throws Exception
     */
    public void markAndResetTest(){
        CharBuffer charBuffer = CharBuffer.allocate(100);
        charBuffer.put("markAndReset test");
        charBuffer.flip();
        while (charBuffer.hasRemaining()){
            char c = charBuffer.get();  //pos has pos++;
            if(c=='A'){
                charBuffer.mark();
            }
            System.out.print(c);
        }
        charBuffer.reset();     //this would point the next position of marked.
        System.out.println("--------"+charBuffer.get());

        //markAndReset test--------n
    }
    public void clearAndcompactTest(){
        CharBuffer charBuffer = CharBuffer.allocate(100);
        charBuffer.put("clearAndcompact Test");
        charBuffer.flip();//limit = position; position = 0;
        while (charBuffer.hasRemaining()){
            char c = charBuffer.get();  //pos has pos++;
            if(c=='A'){
                System.out.println("-----");
//                charBuffer.compact();//position(limit - position);   limit = capacity;   mark = -1
                charBuffer.clear();//position = 0;  limit = capacity;  mark = -1;
                charBuffer.put(" has update ");
                System.out.println("position:"+charBuffer.position());
                charBuffer.rewind();//仅　limit = 0;　　这里不用charBuffer.flip();　因为limit = position，当使用clear()
                while(charBuffer.hasRemaining()){
                    System.out.print(charBuffer.get());
                }
//                char[] cs = new char[24];
//                charBuffer.get(cs,0,24);
//                System.out.println(cs);

                // charBuffer.clear();  -----  has update act Test
                //charBuffer.compact(); ------ ndcompact Test has update
            }else {
                System.out.print(c);
            }
        }

    }

    public void writeFile() throws Exception {
        RandomAccessFile randomAccessFile = new RandomAccessFile("C:\\Users\\asnphtl\\Desktop\\testFile\\NIO_T1.txt","rw");
        FileChannel fileChannel = randomAccessFile.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        fileChannel.write(ByteBuffer.wrap("SS".getBytes(),0,2));
        System.out.println(fileChannel.size());

    }

    /**
     * equals
     * 有相同的类型（byte、char、int等）;
     * Buffer中剩余的byte、char等的个数相等;
     * Buffer中所有剩余的byte、char等都相同。
     */
    public void equalsTest(){
        ByteBuffer b1 = ByteBuffer.allocate(10);
        ByteBuffer b2 = ByteBuffer.allocate(10);
        b1.put("abc".getBytes());
        b2.put("c".getBytes());
        b1.flip();
        b2.flip();
        while (b1.hasRemaining()){
            char c = (char) b1.get();
            if(c == 'b'){
                System.out.println(b1.equals(b2));//true   比较的是position and limit 之间的元素
            }
        }
    }

    /**
     * 第一个不相等的元素小于另一个Buffer中对应的元素。
     * 所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。
     */
    public void comparetoTest(){
        ByteBuffer b1 = ByteBuffer.allocate(10);
        ByteBuffer b2 = ByteBuffer.allocate(10);
        ByteBuffer b3 = ByteBuffer.allocate(10);
        b1.put("abc".getBytes());
        b2.put("bcd".getBytes());
        b3.put("abcd".getBytes());
        b1.flip();
        b2.flip();
        b3.flip();
        System.out.println(b1.compareTo(b2));//-1
        System.out.println(b1.compareTo(b3));//-1
    }

    /**
     * 将 channel 的数据分散写入到多个buffer中，规则是前一个buffer需要写满才进行下一个buffer 的写数据操作
     * 定义好的buffer放入数组，channel 依据放入的顺序写数据
     * @param path
     * @param model
     * @throws Exception
     */
    public void scatterTest(String path,String model) throws Exception{
        RandomAccessFile randomAccessFile = new RandomAccessFile(path,model);
        FileChannel fileChannel = randomAccessFile.getChannel();
        ByteBuffer b1 = ByteBuffer.allocate(3);
        ByteBuffer b2 = ByteBuffer.allocate(3);
        ByteBuffer[] buffers = new ByteBuffer[]{b1,b2};//放入数组
        long fileRead = fileChannel.read(buffers);
        while (fileRead != -1){
            b1.flip();
            b2.flip();
            while (b1.hasRemaining()){
                System.out.print((char) b1.get());
            }
            System.out.println();
            while (b2.hasRemaining()){
                System.out.print((char)b2.get());
            }
            b1.clear();
            b2.clear();
            fileRead = fileChannel.read(buffers);//清空（position = 0;limit = capacity;）buffer，读取后续数据
        }
        randomAccessFile.close();
    }

    /**
     * 将多个buffer 聚集到一个channel
     * @param path
     * @param model
     * @throws Exception
     */
    public void gatherTest(String path,String model)throws Exception{
        RandomAccessFile randomAccessFile = new RandomAccessFile(path,model);
        FileChannel fileChannel = randomAccessFile.getChannel();
        ByteBuffer b1 = ByteBuffer.allocate(3);
        ByteBuffer b2 = ByteBuffer.allocate(3);
        b1.put("efg".getBytes());
        b2.put("swt".getBytes());
        ByteBuffer[] buffers = new ByteBuffer[]{b1,b2};//放入数组
        b1.flip();
        b2.flip();
        fileChannel.write(buffers);
    }

    /**
     * transferTo　和　tranferFrom
     * 将字节从给定的可读取字节通道传输到目标通道的文件中
     * 相当于复制文件
     * @param srcPath
     * @param tagPath
     * @throws Exception
     */
    public void tranferTotTst(String srcPath,String tagPath)throws Exception{
        RandomAccessFile srcFile = new RandomAccessFile(srcPath,"rw");
        RandomAccessFile tagFile = new RandomAccessFile(tagPath,"rw");
        FileChannel srcChannel = srcFile.getChannel();
        FileChannel tagChannel = tagFile.getChannel();
        srcChannel.transferTo(0,4,tagChannel);
        srcFile.close();
        tagFile.close();
    }

    public void socketTest()throws Exception{
        InetSocketAddress socketAddress = new InetSocketAddress("localhost",80);
        SocketChannel socketChannel = SocketChannel.open(socketAddress);
        Selector selector = Selector.open();
        SelectionKey key = socketChannel.register(selector,SelectionKey.OP_CONNECT);
        if(key.isConnectable()){
            System.out.println("connect!");
        }

    }

    /**
     * selector
     * 实现一个线程监控多个 channel  就绪状态
     * 状态包括如下：
     * SelectionKey.OP_CONNECT：某个channel成功连接到另一个服务器
     * SelectionKey.OP_ACCEPT：一个server socket channel准备好接收新进入的连接
     * SelectionKey.OP_READ：一个有数据可读的通道
     * SelectionKey.OP_WRITE：等待写数据的通道
     *
     * @throws Exception
     */
    public void selectorTest()throws Exception{
        Selector selector = Selector.open();    //创建　selector
        SocketChannel channel = SocketChannel.open();   //channel 必须为非阻塞通道，FileChannel 不能切换非阻塞，不适用
        channel.configureBlocking(false);       //切换　channel 为非阻塞状态，
        SelectionKey key = channel.register(selector,SelectionKey.OP_READ); //将channel注册到selector上,并设置需要监听的状态
        while(true){
            //int readyChannels = selector.select();    //返回监听状态已经就绪的channel数,此时若无则处于等待阻塞状态直至有就绪channel
            int readyChannels = selector.selectNow();   //返回监听状态已经就绪的channel数,此时若无则立即返回0

            if(readyChannels==0){
                System.out.println("readyChannel count:"+readyChannels);
                continue;
            }
            Set selectKeys = selector.selectedKeys();   //返回已经监听到的就绪状态的 channel 对象
            Iterator keyIterator = selectKeys.iterator();
            while(keyIterator.hasNext()) {
                SelectionKey key1 = (SelectionKey) keyIterator.next();
                if(key.isAcceptable()) {
                    // a connection was accepted by a ServerSocketChannel.
                } else if (key.isConnectable()) {
                    // a connection was established with a remote server.
                } else if (key.isReadable()) {
                    // a channel is ready for reading
                } else if (key.isWritable()) {
                    // a channel is ready for writing
                }
                keyIterator.remove();   //Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。
                                        // 下次该通道变成就绪时，Selector会再次将其放入已选择键集中。
            }
        }
    }


    public static void main(String[] args) throws Exception {
        Demo1 demo1 = new Demo1();
//        demo1.readFile("C:\\Users\\asnphtl\\Desktop\\testFile\\NIO_T1.txt","rw");
//        demo1.writeFile();
//        demo1.bufferTest();
//        demo1.markAndResetTest();
//        demo1.clearAndcompactTest();
//        demo1.equalsTest();
//        demo1.comparetoTest();
//        demo1.scatterTest("C:\\Users\\asnphtl\\Desktop\\testFile\\NIO_T1.txt","rw");
//        demo1.gatherTest("C:\\Users\\asnphtl\\Desktop\\testFile\\NIO_T1.txt","rw");
//        demo1.tranferTotTst("C:\\Users\\asnphtl\\Desktop\\testFile\\fromFile.txt","C:\\Users\\asnphtl\\Desktop\\testFile\\toFile.txt");
//        demo1.selectorTest();
        demo1.socketTest();
    }
}


